 import "types.dart" show Component , ParsedComponents , ParsedResult , ParsingReference ; import "package:dayjs.dart" dayjs show QUnitType ; import "utils/dayjs.dart" show assignSimilarDate , assignSimilarTime , implySimilarTime ; import "timezone.dart" show toTimezoneOffset ; dayjs . extend ( quarterOfYear ) ; class ReferenceWithTimezone { Date instant ; dynamic /* num | null */ timezoneOffset ; ReferenceWithTimezone ( [ dynamic /* ParsingReference | Date */ input ] ) { input = input ?  ? new Date ( ) :  :  ; if ( input is Date ) { this . instant = input ; } else { this . instant = input . instant ?  ? new Date ( ) :  :  ; this . timezoneOffset = toTimezoneOffset ( input . timezone , this . instant ) ; } }
 /**
     * Returns a JS date (system timezone) with the { year, month, day, hour, minute, second } equal to the reference.
     * The output's instant is NOT the reference's instant when the reference's and system's timezone are different.
     */
 getDateWithAdjustedTimezone ( ) { return new Date ( this . instant . getTime ( ) + this . getSystemTimezoneAdjustmentMinute ( this . instant ) * 60000 ) ; }
 /**
     * Returns the number minutes difference between the JS date's timezone and the reference timezone.
     * 
     * 
     */
 num getSystemTimezoneAdjustmentMinute ( [ Date date , num overrideTimezoneOffset ] ) { if ( ! date || date . getTime ( ) < 0 ) {
 // Javascript date timezone calculation got effect when the time epoch < 0

 // e.g. new Date('Tue Feb 02 1300 00:00:00 GMT+0900 (JST)') => Tue Feb 02 1300 00:18:59 GMT+0918 (JST)
 date = new Date ( ) ; } final currentTimezoneOffset = - date . getTimezoneOffset ( ) ; final targetTimezoneOffset = overrideTimezoneOffset ?  ? this . timezoneOffset ?  ? currentTimezoneOffset :  :  :  :  ; return currentTimezoneOffset - targetTimezoneOffset ; } } class ParsingComponents implements ParsedComponents { dynamic knownValues ; dynamic impliedValues ; ReferenceWithTimezone reference ; ParsingComponents ( ReferenceWithTimezone reference , [ dynamic knownComponents ] ) { this . reference = reference ; this . knownValues = { } ; this . impliedValues = { } ; if ( knownComponents ) { for ( final key in knownComponents ) { this . knownValues [ ] = knownComponents [ ] ; } } final refDayJs = dayjs ( reference . instant ) ; this . imply ( "day" , refDayJs . date ( ) ) ; this . imply ( "month" , refDayJs . month ( ) + 1 ) ; this . imply ( "year" , refDayJs . year ( ) ) ; this . imply ( "hour" , 12 ) ; this . imply ( "minute" , 0 ) ; this . imply ( "second" , 0 ) ; this . imply ( "millisecond" , 0 ) ; } dynamic /* num | null */ get ( Component component ) { if ( ) { return this . knownValues [ component ] ; } if ( ) { return this . impliedValues [ component ] ; } return null ; } bool isCertain ( Component component ) { return ; } Array< Component > getCertainComponents ( ) { return ; } ParsingComponents imply ( Component component , num value ) { if ( ) { return this ; } this . impliedValues [ component ] = value ; return this ; } ParsingComponents assign ( Component component , num value ) { this . knownValues [ component ] = value ; ; return this ; } delete ( Component component ) { ; ; } ParsingComponents clone ( ) { final component = new ParsingComponents ( this . reference ) ; component . knownValues = { } ; component . impliedValues = { } ; for ( final key in this . knownValues ) { component . knownValues [ ] = this . knownValues [ ] ; } for ( final key in this . impliedValues ) { component . impliedValues [ ] = this . impliedValues [ ] ; } return component ; } bool isOnlyDate ( ) { return ! this . isCertain ( "hour" ) && ! this . isCertain ( "minute" ) && ! this . isCertain ( "second" ) ; } bool isOnlyTime ( ) { return ! this . isCertain ( "weekday" ) && ! this . isCertain ( "day" ) && ! this . isCertain ( "month" ) ; } bool isOnlyWeekdayComponent ( ) { return this . isCertain ( "weekday" ) && ! this . isCertain ( "day" ) && ! this . isCertain ( "month" ) ; } bool isDateWithUnknownYear ( ) { return this . isCertain ( "month" ) && ! this . isCertain ( "year" ) ; } bool isValidDate ( ) { final date = this . dateWithoutTimezoneAdjustment ( ) ; if ( ! identical ( date . getFullYear ( ) , this . get ( "year" ) ) ) return false ; if ( ! identical ( date . getMonth ( ) , this . get ( "month" ) - 1 ) ) return false ; if ( ! identical ( date . getDate ( ) , this . get ( "day" ) ) ) return false ; if ( this . get ( "hour" ) != null && date . getHours ( ) != this . get ( "hour" ) ) return false ; if ( this . get ( "minute" ) != null && date . getMinutes ( ) != this . get ( "minute" ) ) return false ; return true ; } toString ( ) { return '''[ParsingComponents {knownValues: ${ JSON . stringify ( this . knownValues )}, impliedValues: ${ JSON . stringify ( this . impliedValues )}}, reference: ${ JSON . stringify ( this . reference )}]''' ; } dayjs ( ) { return dayjs ( this . date ( ) ) ; } Date date ( ) { final date = this . dateWithoutTimezoneAdjustment ( ) ; final timezoneAdjustment = this . reference . getSystemTimezoneAdjustmentMinute ( date , this . get ( "timezoneOffset" ) ) ; return new Date ( date . getTime ( ) + timezoneAdjustment * 60000 ) ; } dateWithoutTimezoneAdjustment ( ) { final date = new Date ( this . get ( "year" ) , this . get ( "month" ) - 1 , this . get ( "day" ) , this . get ( "hour" ) , this . get ( "minute" ) , this . get ( "second" ) , this . get ( "millisecond" ) ) ; date . setFullYear ( this . get ( "year" ) ) ; return date ; } static ParsingComponents createRelativeFromReference ( ReferenceWithTimezone reference , dynamic fragments ) { var date = dayjs ( reference . instant ) ; for ( final key in fragments ) { date = date . add ( fragments [ ] , ) ; } final components = new ParsingComponents ( reference ) ; if ( fragments [ "hour" ] || fragments [ "minute" ] || fragments [ "second" ] ) { assignSimilarTime ( components , date ) ; assignSimilarDate ( components , date ) ; if ( ! identical ( reference . timezoneOffset , null ) ) { components . assign ( "timezoneOffset" , - reference . instant . getTimezoneOffset ( ) ) ; } } else { implySimilarTime ( components , date ) ; if ( ! identical ( reference . timezoneOffset , null ) ) { components . imply ( "timezoneOffset" , - reference . instant . getTimezoneOffset ( ) ) ; } if ( fragments [ "d" ] ) { components . assign ( "day" , date . date ( ) ) ; components . assign ( "month" , date . month ( ) + 1 ) ; components . assign ( "year" , date . year ( ) ) ; } else { if ( fragments [ "week" ] ) { components . imply ( "weekday" , date . day ( ) ) ; } components . imply ( "day" , date . date ( ) ) ; if ( fragments [ "month" ] ) { components . assign ( "month" , date . month ( ) + 1 ) ; components . assign ( "year" , date . year ( ) ) ; } else { components . imply ( "month" , date . month ( ) + 1 ) ; if ( fragments [ "year" ] ) { components . assign ( "year" , date . year ( ) ) ; } else { components . imply ( "year" , date . year ( ) ) ; } } } } return components ; } } class ParsingResult implements ParsedResult { Date refDate ; num index ; String text ; ReferenceWithTimezone reference ; ParsingComponents start ; ParsingComponents end ; ParsingResult ( ReferenceWithTimezone reference , num index , String text , [ ParsingComponents start , ParsingComponents end ] ) { this . reference = reference ; this . refDate = reference . instant ; this . index = index ; this . text = text ; this . start = start || new ParsingComponents ( reference ) ; this . end = end ; } clone ( ) { final result = new ParsingResult ( this . reference , this . index , this . text ) ; result . start = this . start ? this . start . clone ( ) : null ; result . end = this . end ? this . end . clone ( ) : null ; return result ; } Date date ( ) { return this . start . date ( ) ; } toString ( ) { return '''[ParsingResult {index: ${ this . index}, text: \'${ this . text}\', ...}]''' ; } }